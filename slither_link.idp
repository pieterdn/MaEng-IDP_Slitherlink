vocabulary V {
    // Types
    type cell_column        // Column of a cell
    type cell_row           // Row of a cell
    type point_column       // Column of a point, amount = amount of cell cols + 1
    type point_row          // Row of a point, amount = amount of cell rows + 1
    type cell_value         // Possible cell values
    
    // cells
    Value: (cell_column * cell_row) → cell_value
    n_cell: (cell_column * cell_row * cell_column * cell_row) → Bool
    e_cell: (cell_column * cell_row * cell_column * cell_row) → Bool
    w_cell: (cell_column * cell_row * cell_column * cell_row) → Bool
    s_cell: (cell_column * cell_row * cell_column * cell_row) → Bool
    nw_cp: (cell_column * cell_row * point_column * point_row) → Bool
    ne_cp: (cell_column * cell_row * point_column * point_row) → Bool
    sw_cp: (cell_column * cell_row * point_column * point_row) → Bool
    se_cp: (cell_column * cell_row * point_column * point_row) → Bool
    
    // Points
    n_point: (point_column * point_row * point_column * point_row) → Bool
    e_point: (point_column * point_row * point_column * point_row) → Bool
    s_point: (point_column * point_row * point_column * point_row) → Bool
    w_point: (point_column * point_row * point_column * point_row) → Bool
    nw_pc: (point_column * point_row * cell_column * cell_row) → Bool
    ne_pc: (point_column * point_row * cell_column * cell_row) → Bool
    sw_pc: (point_column * point_row * cell_column * cell_row) → Bool
    se_pc: (point_column * point_row * cell_column * cell_row) → Bool

    // Lines
    line: (point_column * point_row * point_column * point_row) → Bool
}

theory T:V {
    // !cols in cell_column: !rows in cell_row: (Value(cols, rows) ~= -1) => #{colsp1, colsp2 in point_column: !rowsp1, rowsp2 in point_row: (nw_cp(cols, rows, colsp1, rowsp1) & ne_cp(cols, rows, colsp2, rowsp2)) | (ne_cp(cols, rows, colsp1, rowsp1) & se_cp(cols, rows, colsp2, rowsp2)) | (se_cp(cols, rows, colsp1, rowsp1) & sw_cp(cols, rows, colsp2, rowsp2)) | (sw_cp(cols, rows, colsp1, rowsp1) & nw_cp(cols, rows, colsp2, rowsp2)) => line(colsp1, rowsp1, colsp2, rowsp2)} = (Value(cols, rows)). 
    // itereer door alle punten 2 keer, indien twee punten rond deze cell, kijk of er een lijn is tussen twee punten

    // 1. De lijnen moeten 1 doorlopende, niet kruisende kring vormen.
    //      - Uit elk punt start geen of 2 lijnen (Zorgt voor geen kruisingen)
    // 2. De value van elke cel komt overeen met het aantal omringende lijnen.
    //      - 

    
}

structure S:V {
    // 3 by 3 Slitherlink
    // -------------
    // | 0 | 2 | 3 |
    // -------------
    // |   | 2 |   |
    // -------------
    // |   | 1 | 2 |
    // -------------
    cell_column := {1, 2, 3}.
    cell_row := {1, 2, 3}.
    point_column := {1, 2, 3, 4}.
    point_row := {1, 2, 3, 4}.
    cell_value := {-1, 0, 1, 2, 3}.
    Value := {(1, 1) → 0, (2, 1) → 2, (3, 1) → 3, (2, 2) → 2, (2, 3) → 1, (3, 3) → 2} else -1.
    
    // cell relations, how one cell lies in relation to another
    n_cell := {(1, 2, 1, 1), (1, 3, 1, 2), (2, 2, 2, 1), (2, 3, 2, 2), (3, 2, 3, 1), (3, 3, 3, 2)}.
    e_cell := {(1, 1, 2, 1), (1, 2, 2, 2), (1, 3, 2, 3), (2, 1, 3, 1), (2, 2, 3, 2), (2, 3, 3, 3)}.
    s_cell := {(1, 1, 1, 2), (1, 2, 1, 3), (2, 1, 2, 2), (2, 2, 2, 3), (3, 1, 3, 2), (3, 2, 3, 3)}.
    w_cell := {(2, 1, 1, 1), (2, 2, 1, 2), (2, 3, 1, 3), (3, 1, 2, 1), (3, 2, 2, 2), (3, 3, 2, 3)}.

    // Point relations, how one point lies in relation to another
    n_point := {(1, 2, 1, 1), (2, 2, 2, 1), (3, 2, 3, 1), (4, 2, 4, 1), (1, 3, 1, 2), (2, 3, 2, 2), (3, 3, 3, 2), (4, 3, 4, 2), (1, 4, 1, 3), (2, 4, 2, 3), (3, 4, 3, 3), (4, 4, 4, 3)}.
    e_point := {(1, 1, 2, 1), (2, 1, 3, 1), (3, 1, 4, 1), (1, 2, 2, 2), (2, 2, 3, 2), (3, 2, 4, 2), (1, 3, 2, 3), (2, 3, 3, 3), (3, 3, 4, 3), (1, 4, 2, 4), (2, 4, 3, 4), (3, 4, 4, 4)}.
    s_point := {(1, 1, 1, 2), (2, 1, 2, 2), (3, 1, 3, 2), (4, 1, 4, 2), (1, 2, 1, 3), (2, 2, 2, 3), (3, 2, 3, 3), (4, 2, 4, 3), (1, 3, 1, 4), (2, 3, 2, 4), (3, 3, 3, 4), (4, 3, 4, 4)}.
    w_point := {(2, 1, 1, 1), (3, 1, 2, 1), (4, 1, 3, 1), (2, 2, 1, 2), (3, 2, 2, 2), (4, 2, 3, 2), (2, 3, 1, 3), (3, 3, 2, 3), (4, 3, 3, 3), (2, 4, 1, 4), (3, 4, 2, 4), (4, 4, 3, 4)}.

    // Point to cell relations, how a point lies in relation to a cell
    nw_cp := {(1, 1, 1, 1), (2, 1, 2, 1), (3, 1, 3, 1), (1, 2, 1, 2), (2, 2, 2, 2), (3, 2, 3, 2), (1, 3, 1, 3), (2, 3, 2, 3), (3, 3, 3, 3)}.
    ne_cp := {(1, 1, 2, 1), (2, 1, 3, 1), (3, 1, 4, 1), (1, 2, 2, 2), (2, 2, 3, 2), (3, 2, 4, 2), (1, 3, 2, 3), (2, 3, 3, 3), (3, 3, 4, 3)}.
    sw_cp := {(1, 1, 1, 2), (2, 1, 2, 2), (3, 1, 3, 2), (1, 2, 1, 3), (2, 2, 2, 3), (3, 2, 3, 3), (1, 3, 1, 4), (2, 3, 2, 4), (3, 3, 3, 4)}.
    se_cp := {(1, 1, 2, 2), (2, 1, 3, 2), (3, 1, 4, 2), (1, 2, 2, 3), (2, 2, 3, 3), (3, 2, 4, 3), (1, 3, 2, 4), (2, 3, 3, 4), (3, 3, 4, 4)}.

    // cell to point relations, how a cell lies in relation to a point
    nw_pc := {(2, 2, 1, 1), (3, 2, 2, 1), (4, 2, 3, 1), (2, 3, 1, 2), (3, 3, 2, 2), (4, 3, 3, 2), (2, 4, 1, 3), (3, 4, 2, 3), (4, 4, 3, 3)}.
    ne_pc := {(1, 2, 1, 1), (2, 2, 2, 1), (3, 2, 3, 1), (1, 3, 1, 2), (2, 3, 2, 2), (3, 3, 3, 2), (1, 4, 1, 3), (2, 4, 2, 3), (3, 4, 3, 3)}.
    sw_pc := {(2, 1, 1, 1), (3, 1, 2, 1), (4, 1, 3, 1), (2, 2, 1, 2), (3, 2, 2, 2), (4, 2, 3, 2), (2, 3, 1, 3), (3, 3, 2, 3), (4, 3, 3, 3)}.
    se_pc := {(1, 1, 1, 1), (2, 1, 2, 1), (3, 1, 3, 1), (1, 2, 1, 2), (2, 2, 2, 2), (3, 2, 3, 2), (1, 3, 1, 3), (2, 3, 2, 3), (3, 3, 3, 3)}.
}

procedure main() {
    pretty_print(model_expand(T, S))
}
