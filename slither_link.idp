vocabulary V {
    // Types
    type cell_column        // Column of a cell
    type cell_row           // Row of a cell
    type point_column       // Column of a point, amount = amount of cell cols + 1
    type point_row          // Row of a point, amount = amount of cell rows + 1
    type cell_value         // Possible cell values
    
    // cells
    Value: (cell_column * cell_row) -> cell_value
    n_cell: (cell_column * cell_row * cell_column * cell_row) -> Bool
    e_cell: (cell_column * cell_row * cell_column * cell_row) -> Bool
    w_cell: (cell_column * cell_row * cell_column * cell_row) -> Bool
    s_cell: (cell_column * cell_row * cell_column * cell_row) -> Bool

    neighbor_cell: (cell_column * cell_row * cell_column * cell_row) -> Bool
    cell_point: (cell_column * cell_row * point_column * point_row) -> Bool

    nw_cp: (cell_column * cell_row * point_column * point_row) -> Bool
    ne_cp: (cell_column * cell_row * point_column * point_row) -> Bool
    sw_cp: (cell_column * cell_row * point_column * point_row) -> Bool
    se_cp: (cell_column * cell_row * point_column * point_row) -> Bool
    
    // Points
    n_point: (point_column * point_row * point_column * point_row) -> Bool
    e_point: (point_column * point_row * point_column * point_row) -> Bool
    s_point: (point_column * point_row * point_column * point_row) -> Bool
    w_point: (point_column * point_row * point_column * point_row) -> Bool
    
    neighbor_point: (point_column * point_row * point_column * point_row) -> Bool

    nw_pc: (point_column * point_row * cell_column * cell_row) -> Bool
    ne_pc: (point_column * point_row * cell_column * cell_row) -> Bool
    sw_pc: (point_column * point_row * cell_column * cell_row) -> Bool
    se_pc: (point_column * point_row * cell_column * cell_row) -> Bool

    // Lines
    line: (point_column * point_row * point_column * point_row) -> Bool
}

theory T:V {
    // Defines neighboring cells
    !x, x2 in cell_column: !y, y2 in cell_row: n_cell(x, y, x2, y2) | e_cell(x, y, x2, y2) | s_cell(x, y, x2, y2) | w_cell(x, y, x2, y2) <=> neighbor_cell(x, y, x2, y2).
    
    // Defines neighboring points
    !x, x2 in point_column: !y, y2 in point_row: n_point(x, y, x2, y2) | e_point(x, y, x2, y2) | s_point(x, y, x2, y2) | w_point(x, y, x2, y2) <=> neighbor_point(x, y, x2, y2).

    // Defines which points are part of which cells
    !x in cell_column: !y in cell_row: !x2 in point_column: !y2 in point_row: nw_cp(x, y, x2, y2) | ne_cp(x, y, x2, y2) | sw_cp(x, y, x2, y2) | se_cp(x, y, x2, y2) <=> cell_point(x, y, x2, y2).
    
    // Eliminates lines between not neighboring points
    !x, x2 in point_column: !y, y2 in point_row: ~neighbor_point(x, y, x2, y2) => ~line(x, y, x2, y2).
    
    // Out of every point starts 0 or 2 lines 
    !x in point_column: !y in point_row: (#{x2 in point_column, y2 in point_row: line(x, y, x2, y2)} = 0) | (#{x2 in point_column, y2 in point_row: line(x, y, x2, y2)} = 2).

    // Every cell value is the sum of the surrounding lines
    //!x in cell_column: !y in cell_row: Value(x,y) = #{line(x, y, x+1, y)} + #{line(x, y, x, y+1)} + #{line(x+1, y, x+1, y+1)} + #{line(x, y+1, x+1, y+1)} + #{line(x+1, y, x, y)} + #{line(x, y+1, x, y)} + #{line(x+1, y+1, x+1, y)} + #{line(x+1, y+1, x, y+1)}.

    // !x, x2 in cell_column: !y, y2 in cell_row: Value(x, y) = #{x3 in point_column, y3 in point_row: line(x3, y3, x, y)} + #{x3 in point_column, y3 in point_row: line(x3, y3, x2, y2)} + #{x3 in point_column, y3 in point_row: line(x3, y3, x, y2)} + #{x3 in point_column, y3 in point_row: line(x3, y3, x2, y)}.

    // [] 1. De lijnen moeten 1 doorlopende, niet kruisende kring vormen.
    //      [X] - Uit elk punt start geen of 2 lijnen (Zorgt voor geen kruisingen) 
    // [] 2. De value van elke cel komt overeen met het aantal omringende lijnen.
    //      - 
    // [] 3. Som all values = aantal lijnen
   
}

structure S:V {
    // 3 by 3 Slitherlink
    // -------------
    // | 0 | 2 | 3 |
    // -------------
    // |   | 2 |   |
    // -------------
    // |   | 1 | 2 |
    // -------------
    cell_column := {1, 2, 3}.
    cell_row := {1, 2, 3}.
    point_column := {1, 2, 3, 4}.
    point_row := {1, 2, 3, 4}.
    cell_value := {-1, 0, 1, 2, 3}.
    Value := {(1, 1) -> 0, (2, 1) -> 2, (3, 1) -> 3, (2, 2) -> 2, (2, 3) -> 1, (3, 3) -> 2} else -1.
    
    // cell relations, how one cell lies in relation to another
    n_cell := {(1, 2, 1, 1), (1, 3, 1, 2), (2, 2, 2, 1), (2, 3, 2, 2), (3, 2, 3, 1), (3, 3, 3, 2)}.
    e_cell := {(1, 1, 2, 1), (1, 2, 2, 2), (1, 3, 2, 3), (2, 1, 3, 1), (2, 2, 3, 2), (2, 3, 3, 3)}.
    s_cell := {(1, 1, 1, 2), (1, 2, 1, 3), (2, 1, 2, 2), (2, 2, 2, 3), (3, 1, 3, 2), (3, 2, 3, 3)}.
    w_cell := {(2, 1, 1, 1), (2, 2, 1, 2), (2, 3, 1, 3), (3, 1, 2, 1), (3, 2, 2, 2), (3, 3, 2, 3)}.

    // Point relations, how one point lies in relation to another
    n_point := {(1, 2, 1, 1), (2, 2, 2, 1), (3, 2, 3, 1), (4, 2, 4, 1), (1, 3, 1, 2), (2, 3, 2, 2), (3, 3, 3, 2), (4, 3, 4, 2), (1, 4, 1, 3), (2, 4, 2, 3), (3, 4, 3, 3), (4, 4, 4, 3)}.
    e_point := {(1, 1, 2, 1), (2, 1, 3, 1), (3, 1, 4, 1), (1, 2, 2, 2), (2, 2, 3, 2), (3, 2, 4, 2), (1, 3, 2, 3), (2, 3, 3, 3), (3, 3, 4, 3), (1, 4, 2, 4), (2, 4, 3, 4), (3, 4, 4, 4)}.
    s_point := {(1, 1, 1, 2), (2, 1, 2, 2), (3, 1, 3, 2), (4, 1, 4, 2), (1, 2, 1, 3), (2, 2, 2, 3), (3, 2, 3, 3), (4, 2, 4, 3), (1, 3, 1, 4), (2, 3, 2, 4), (3, 3, 3, 4), (4, 3, 4, 4)}.
    w_point := {(2, 1, 1, 1), (3, 1, 2, 1), (4, 1, 3, 1), (2, 2, 1, 2), (3, 2, 2, 2), (4, 2, 3, 2), (2, 3, 1, 3), (3, 3, 2, 3), (4, 3, 3, 3), (2, 4, 1, 4), (3, 4, 2, 4), (4, 4, 3, 4)}.

    // Point to cell relations, how a point lies in relation to a cell
    nw_cp := {(1, 1, 1, 1), (2, 1, 2, 1), (3, 1, 3, 1), (1, 2, 1, 2), (2, 2, 2, 2), (3, 2, 3, 2), (1, 3, 1, 3), (2, 3, 2, 3), (3, 3, 3, 3)}.
    ne_cp := {(1, 1, 2, 1), (2, 1, 3, 1), (3, 1, 4, 1), (1, 2, 2, 2), (2, 2, 3, 2), (3, 2, 4, 2), (1, 3, 2, 3), (2, 3, 3, 3), (3, 3, 4, 3)}.
    sw_cp := {(1, 1, 1, 2), (2, 1, 2, 2), (3, 1, 3, 2), (1, 2, 1, 3), (2, 2, 2, 3), (3, 2, 3, 3), (1, 3, 1, 4), (2, 3, 2, 4), (3, 3, 3, 4)}.
    se_cp := {(1, 1, 2, 2), (2, 1, 3, 2), (3, 1, 4, 2), (1, 2, 2, 3), (2, 2, 3, 3), (3, 2, 4, 3), (1, 3, 2, 4), (2, 3, 3, 4), (3, 3, 4, 4)}.

    // cell to point relations, how a cell lies in relation to a point
    nw_pc := {(2, 2, 1, 1), (3, 2, 2, 1), (4, 2, 3, 1), (2, 3, 1, 2), (3, 3, 2, 2), (4, 3, 3, 2), (2, 4, 1, 3), (3, 4, 2, 3), (4, 4, 3, 3)}.
    ne_pc := {(1, 2, 1, 1), (2, 2, 2, 1), (3, 2, 3, 1), (1, 3, 1, 2), (2, 3, 2, 2), (3, 3, 3, 2), (1, 4, 1, 3), (2, 4, 2, 3), (3, 4, 3, 3)}.
    sw_pc := {(2, 1, 1, 1), (3, 1, 2, 1), (4, 1, 3, 1), (2, 2, 1, 2), (3, 2, 2, 2), (4, 2, 3, 2), (2, 3, 1, 3), (3, 3, 2, 3), (4, 3, 3, 3)}.
    se_pc := {(1, 1, 1, 1), (2, 1, 2, 1), (3, 1, 3, 1), (1, 2, 1, 2), (2, 2, 2, 2), (3, 2, 3, 2), (1, 3, 1, 3), (2, 3, 2, 3), (3, 3, 3, 3)}.
}

procedure main() {
    pretty_print(model_expand(T, S))
}
